name: Run Benchmarks

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  push:
    branches:
      - main
    paths:
      - 'scripts/**'
      - 'benches/**'
      - '.github/workflows/benchmarks.yml'

jobs:
  run-benchmarks:
    outputs:
      json_file: ${{ steps.find_json.outputs.json_file }}
    runs-on: [self-hosted, linux]  # Self-hosted runner required
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Setup dependencies (Core and Commons)
        id: setup
        run: |
          echo "Setting up Bitcoin Core and Bitcoin Commons..."
          
          # Setup Core
          CORE_DIR="$HOME/bitcoin-core"
          if [ ! -d "$CORE_DIR" ]; then
            echo "Cloning Bitcoin Core to $CORE_DIR..."
            git clone --depth 1 https://github.com/bitcoin/bitcoin.git "$CORE_DIR" || {
              echo "‚ùå Failed to clone Core"
              exit 1
            }
          else
            echo "‚úÖ Bitcoin Core already exists at $CORE_DIR"
          fi
          
          # Setup Commons consensus
          # Clone to both $HOME (for path discovery) and relative to bllvm-bench (for Cargo.toml)
          CONSENSUS_DIR="$HOME/bllvm-consensus"
          BENCH_ROOT="$(pwd)"
          RELATIVE_CONSENSUS_DIR="$BENCH_ROOT/../bllvm-consensus"
          
          if [ ! -d "$CONSENSUS_DIR" ]; then
            echo "Cloning Bitcoin Commons (bllvm-consensus) to $CONSENSUS_DIR..."
            git clone --depth 1 https://github.com/BTCDecoded/bllvm-consensus.git "$CONSENSUS_DIR" || {
              echo "‚ùå Failed to clone bllvm-consensus"
              exit 1
            }
          else
            echo "‚úÖ bllvm-consensus already exists at $CONSENSUS_DIR"
          fi
          
          # Also create symlink or copy for Cargo.toml path dependency
          if [ ! -d "$RELATIVE_CONSENSUS_DIR" ]; then
            echo "Creating symlink for Cargo.toml path dependency..."
            mkdir -p "$(dirname "$RELATIVE_CONSENSUS_DIR")"
            ln -s "$CONSENSUS_DIR" "$RELATIVE_CONSENSUS_DIR" || {
              echo "‚ö†Ô∏è  Symlink failed, trying copy..."
              cp -r "$CONSENSUS_DIR" "$RELATIVE_CONSENSUS_DIR" || echo "‚ö†Ô∏è  Copy also failed"
            }
          fi
          
          # Setup Commons node
          NODE_DIR="$HOME/bllvm-node"
          RELATIVE_NODE_DIR="$BENCH_ROOT/../bllvm-node"
          
          if [ ! -d "$NODE_DIR" ]; then
            echo "Cloning Bitcoin Commons (bllvm-node) to $NODE_DIR..."
            git clone --depth 1 https://github.com/BTCDecoded/bllvm-node.git "$NODE_DIR" || {
              echo "‚ùå Failed to clone bllvm-node"
              exit 1
            }
          else
            echo "‚úÖ bllvm-node already exists at $NODE_DIR"
          fi
          
          # Also create symlink for Cargo.toml path dependency
          if [ ! -d "$RELATIVE_NODE_DIR" ]; then
            echo "Creating symlink for Cargo.toml path dependency..."
            mkdir -p "$(dirname "$RELATIVE_NODE_DIR")"
            ln -s "$NODE_DIR" "$RELATIVE_NODE_DIR" || {
              echo "‚ö†Ô∏è  Symlink failed, trying copy..."
              cp -r "$NODE_DIR" "$RELATIVE_NODE_DIR" || echo "‚ö†Ô∏è  Copy also failed"
            }
          fi
          
          # Setup Commons protocol (needed for bllvm-bench Cargo.toml)
          PROTOCOL_DIR="$HOME/bllvm-protocol"
          RELATIVE_PROTOCOL_DIR="$BENCH_ROOT/../bllvm-protocol"
          
          if [ ! -d "$PROTOCOL_DIR" ]; then
            echo "Cloning Bitcoin Commons (bllvm-protocol) to $PROTOCOL_DIR..."
            git clone --depth 1 https://github.com/BTCDecoded/bllvm-protocol.git "$PROTOCOL_DIR" || {
              echo "‚ö†Ô∏è  Failed to clone bllvm-protocol (may not be needed)"
            }
          else
            echo "‚úÖ bllvm-protocol already exists at $PROTOCOL_DIR"
          fi
          
          # Also create symlink for Cargo.toml path dependency
          if [ ! -d "$RELATIVE_PROTOCOL_DIR" ] && [ -d "$PROTOCOL_DIR" ]; then
            echo "Creating symlink for bllvm-protocol Cargo.toml path dependency..."
            mkdir -p "$(dirname "$RELATIVE_PROTOCOL_DIR")"
            ln -s "$PROTOCOL_DIR" "$RELATIVE_PROTOCOL_DIR" || {
              echo "‚ö†Ô∏è  Symlink failed, trying copy..."
              cp -r "$PROTOCOL_DIR" "$RELATIVE_PROTOCOL_DIR" || echo "‚ö†Ô∏è  Copy also failed"
            }
          fi
          
          # Verify directories exist
          if [ ! -d "$CORE_DIR" ]; then
            echo "‚ùå Core directory does not exist: $CORE_DIR"
            exit 1
          fi
          if [ ! -d "$CONSENSUS_DIR" ]; then
            echo "‚ùå Consensus directory does not exist: $CONSENSUS_DIR"
            exit 1
          fi
          if [ ! -d "$NODE_DIR" ]; then
            echo "‚ùå Node directory does not exist: $NODE_DIR"
            exit 1
          fi
          
          # Verify symlinks for Cargo.toml
          if [ ! -d "$RELATIVE_CONSENSUS_DIR" ]; then
            echo "‚ö†Ô∏è  Warning: Cargo.toml path dependency not found: $RELATIVE_CONSENSUS_DIR"
            echo "   Commons benchmarks may fail to compile"
          else
            echo "‚úÖ Cargo.toml path dependency found: $RELATIVE_CONSENSUS_DIR"
          fi
          if [ ! -d "$RELATIVE_NODE_DIR" ]; then
            echo "‚ö†Ô∏è  Warning: Cargo.toml path dependency not found: $RELATIVE_NODE_DIR"
          else
            echo "‚úÖ Cargo.toml path dependency found: $RELATIVE_NODE_DIR"
          fi
          
          # Create config.toml with absolute paths
          mkdir -p config
          {
            echo "[paths]"
            echo "core_path = \"$CORE_DIR\""
            echo "commons_consensus_path = \"$CONSENSUS_DIR\""
            echo "commons_node_path = \"$NODE_DIR\""
          } > config/config.toml
          echo "‚úÖ Created config/config.toml"
          echo "Config contents:"
          cat config/config.toml
          
          # Export paths for this step
          echo "core_path=$CORE_DIR" >> $GITHUB_OUTPUT
          echo "commons_consensus_path=$CONSENSUS_DIR" >> $GITHUB_OUTPUT
          echo "commons_node_path=$NODE_DIR" >> $GITHUB_OUTPUT
          
          echo ""
          echo "‚úÖ Setup complete:"
          echo "  CORE_PATH: $CORE_DIR"
          echo "  COMMONS_CONSENSUS_PATH: $CONSENSUS_DIR"
          echo "  COMMONS_NODE_PATH: $NODE_DIR"

      - name: Build Bitcoin Core (bench_bitcoin)
        run: |
          CORE_PATH="${{ steps.setup.outputs.core_path }}"
          echo "Building Bitcoin Core with benchmarks enabled..."
          echo "CORE_PATH: $CORE_PATH"
          
          if [ ! -d "$CORE_PATH" ]; then
            echo "‚ùå CORE_PATH does not exist: $CORE_PATH"
            exit 1
          fi
          
          cd "$CORE_PATH"
          
          # Build with CMake (modern Core)
          echo "Configuring with CMake..."
          cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_BENCH=ON -DENABLE_WALLET=OFF -DBUILD_GUI=OFF || {
            echo "‚ö†Ô∏è  CMake configure failed, trying autotools..."
            ./autogen.sh || echo "‚ö†Ô∏è  autogen.sh failed"
            ./configure --enable-bench --disable-wallet --disable-gui || {
              echo "‚ùå Configure failed"
              exit 1
            }
            make -j$(nproc) bench_bitcoin || {
              echo "‚ùå Build failed"
              exit 1
            }
            exit 0
          }
          
          echo "Building bench_bitcoin..."
          cmake --build build -t bench_bitcoin -j$(nproc) || {
            echo "‚ùå Failed to build bench_bitcoin"
            exit 1
          }
          
          # Verify bench_bitcoin exists
          if [ -f "build/bin/bench_bitcoin" ]; then
            echo "‚úÖ bench_bitcoin built successfully at build/bin/bench_bitcoin"
          else
            echo "‚ùå bench_bitcoin not found after build"
            ls -la build/bin/ 2>/dev/null || echo "build/bin/ does not exist"
            exit 1
          fi

      - name: Verify paths and set environment
        run: |
          # Get paths from previous step
          CORE_PATH="${{ steps.setup.outputs.core_path }}"
          COMMONS_CONSENSUS_PATH="${{ steps.setup.outputs.commons_consensus_path }}"
          COMMONS_NODE_PATH="${{ steps.setup.outputs.commons_node_path }}"
          
          echo "Verifying paths from setup step:"
          echo "  CORE_PATH: $CORE_PATH"
          echo "  COMMONS_CONSENSUS_PATH: $COMMONS_CONSENSUS_PATH"
          echo "  COMMONS_NODE_PATH: $COMMONS_NODE_PATH"
          
          # Verify they exist
          if [ ! -d "$COMMONS_CONSENSUS_PATH" ]; then
            echo "‚ùå COMMONS_CONSENSUS_PATH does not exist: $COMMONS_CONSENSUS_PATH"
            exit 1
          fi
          if [ ! -d "$COMMONS_NODE_PATH" ]; then
            echo "‚ùå COMMONS_NODE_PATH does not exist: $COMMONS_NODE_PATH"
            exit 1
          fi
          
          # Verify bench_bitcoin exists
          if [ -f "$CORE_PATH/build/bin/bench_bitcoin" ]; then
            echo "‚úÖ bench_bitcoin found at $CORE_PATH/build/bin/bench_bitcoin"
          else
            echo "‚ö†Ô∏è  bench_bitcoin not found - Core benchmarks will fail"
          fi
          
          # Test path discovery
          echo ""
          echo "Testing path discovery..."
          source ./scripts/discover-paths.sh
          
          echo ""
          echo "Discovered paths:"
          echo "  CORE_PATH: ${CORE_PATH:-NOT SET}"
          echo "  COMMONS_CONSENSUS_PATH: ${COMMONS_CONSENSUS_PATH:-NOT SET}"
          echo "  COMMONS_NODE_PATH: ${COMMONS_NODE_PATH:-NOT SET}"
          
          if [ -z "$COMMONS_CONSENSUS_PATH" ]; then
            echo "‚ùå COMMONS_CONSENSUS_PATH is still not set after discovery!"
            exit 1
          fi
          
          echo "‚úÖ Paths verified and ready"

      - name: Check dependencies
        env:
          CORE_PATH: ${{ steps.setup.outputs.core_path }}
          COMMONS_CONSENSUS_PATH: ${{ steps.setup.outputs.commons_consensus_path }}
          COMMONS_NODE_PATH: ${{ steps.setup.outputs.commons_node_path }}
        run: |
          export CORE_PATH="$CORE_PATH"
          export COMMONS_CONSENSUS_PATH="$COMMONS_CONSENSUS_PATH"
          export COMMONS_NODE_PATH="$COMMONS_NODE_PATH"
          ./scripts/check-dependencies.sh
          echo "‚úÖ Dependencies check passed"

      - name: Run benchmarks
        env:
          RUSTFLAGS: "-C target-cpu=native"
          CORE_PATH: ${{ steps.setup.outputs.core_path }}
          COMMONS_CONSENSUS_PATH: ${{ steps.setup.outputs.commons_consensus_path }}
          COMMONS_NODE_PATH: ${{ steps.setup.outputs.commons_node_path }}
        run: |
          # Explicitly export paths BEFORE running any scripts
          export CORE_PATH="$CORE_PATH"
          export COMMONS_CONSENSUS_PATH="$COMMONS_CONSENSUS_PATH"
          export COMMONS_NODE_PATH="$COMMONS_NODE_PATH"
          export BLLVM_BENCH_CONFIG="$(pwd)/config/config.toml"
          
          echo "Running benchmarks with paths:"
          echo "  CORE_PATH: $CORE_PATH"
          echo "  COMMONS_CONSENSUS_PATH: $COMMONS_CONSENSUS_PATH"
          echo "  COMMONS_NODE_PATH: $COMMONS_NODE_PATH"
          echo "  Config file: $BLLVM_BENCH_CONFIG"
          
          # Verify paths exist
          if [ ! -d "$COMMONS_CONSENSUS_PATH" ]; then
            echo "‚ùå COMMONS_CONSENSUS_PATH does not exist: $COMMONS_CONSENSUS_PATH"
            exit 1
          fi
          if [ ! -d "$COMMONS_NODE_PATH" ]; then
            echo "‚ùå COMMONS_NODE_PATH does not exist: $COMMONS_NODE_PATH"
            exit 1
          fi
          
          # Verify Core path exists (required for full coverage)
          if [ ! -d "$CORE_PATH" ]; then
            echo "‚ùå CORE_PATH does not exist: $CORE_PATH"
            echo "   Core benchmarks are REQUIRED for full coverage"
            exit 1
          fi
          echo "‚úÖ Core path verified: $CORE_PATH"
          
          # Verify config file exists
          if [ ! -f "$BLLVM_BENCH_CONFIG" ]; then
            echo "‚ùå Config file does not exist: $BLLVM_BENCH_CONFIG"
            exit 1
          fi
          
          echo "‚úÖ All paths verified:"
          echo "   CORE_PATH: $CORE_PATH"
          echo "   COMMONS_CONSENSUS_PATH: $COMMONS_CONSENSUS_PATH"
          echo "   COMMONS_NODE_PATH: $COMMONS_NODE_PATH"
          echo ""
          echo "üöÄ Running ALL benchmarks for FULL coverage..."
          # Run ALL benchmarks (both Core and Commons) for maximum coverage
          ./run-benchmarks.sh all 600
          
          # Verify benchmarks ran
          echo ""
          echo "=== Verifying benchmark execution ==="
          CORE_COUNT=$(find results -name "core-*.json" -type f | wc -l)
          COMMONS_COUNT=$(find results -name "commons-*.json" -type f | wc -l)
          echo "Core benchmarks generated: $CORE_COUNT"
          echo "Commons benchmarks generated: $COMMONS_COUNT"
          if [ "$CORE_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  WARNING: No Core benchmarks generated! Full coverage not achieved."
          fi
          if [ "$COMMONS_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  WARNING: No Commons benchmarks generated!"
          fi
          echo "Total: $((CORE_COUNT + COMMONS_COUNT)) benchmark files"

      - name: Generate consolidated JSON
        run: |
          make json

      - name: Validate consolidated JSON
        run: |
          LATEST_JSON="results/benchmark-results-consolidated-latest.json"
          if [ -f "$LATEST_JSON" ]; then
            ./scripts/validate-benchmark.sh "$LATEST_JSON" || echo "‚ö†Ô∏è  Validation warnings"
          fi

      - name: Track history
        run: |
          LATEST_JSON="results/benchmark-results-consolidated-latest.json"
          if [ -f "$LATEST_JSON" ]; then
            ./scripts/track-history.sh "$LATEST_JSON" || echo "‚ö†Ô∏è  History tracking failed"
          fi

      - name: Detect regressions
        continue-on-error: true
        run: |
          LATEST_JSON="results/benchmark-results-consolidated-latest.json"
          if [ -f "$LATEST_JSON" ]; then
            ./scripts/detect-regressions.sh "$LATEST_JSON" || echo "‚ö†Ô∏è  Regressions detected (see report)"
          fi

      - name: Find consolidated JSON
        id: find_json
        run: |
          LATEST_JSON="results/benchmark-results-consolidated-latest.json"
          if [ ! -f "$LATEST_JSON" ]; then
            echo "‚ùå No consolidated JSON found at $LATEST_JSON"
            exit 1
          fi
          echo "json_file=$LATEST_JSON" >> $GITHUB_OUTPUT
          echo "Found: $LATEST_JSON"

      - name: Archive old releases (if any)
        run: |
          # Archive releases older than 1 week (skip if no releases exist)
          ONE_WEEK_AGO=$(date -u -d '1 week ago' +%Y-%m-%dT%H:%M:%SZ)
          
          # Get all releases with "benchmarks-" prefix (excluding "benchmarks-latest")
          RELEASES=$(gh release list --repo ${{ github.repository }} --limit 100 --json tagName,createdAt,id 2>/dev/null | jq -r '.[] | select(.tagName | startswith("benchmarks-")) | select(.tagName != "benchmarks-latest") | "\(.tagName)|\(.createdAt)|\(.id)"' || echo "")
          
          if [ -z "$RELEASES" ]; then
            echo "No old releases to archive"
            exit 0
          fi
          
          for release_info in $RELEASES; do
            TAG=$(echo "$release_info" | cut -d'|' -f1)
            CREATED=$(echo "$release_info" | cut -d'|' -f2)
            RELEASE_ID=$(echo "$release_info" | cut -d'|' -f3)
            
            # Compare dates (CREATED is ISO 8601 format)
            CREATED_EPOCH=$(date -u -d "$CREATED" +%s 2>/dev/null || echo "0")
            ONE_WEEK_AGO_EPOCH=$(date -u -d "$ONE_WEEK_AGO" +%s 2>/dev/null || echo "0")
            
            if [ "$CREATED_EPOCH" -lt "$ONE_WEEK_AGO_EPOCH" ] && [ "$CREATED_EPOCH" -gt 0 ]; then
              echo "Archiving old release: $TAG (created: $CREATED)"
              # Update release title to mark as archived
              gh release edit "$TAG" --title "Archived: $TAG" --repo ${{ github.repository }} || echo "‚ö†Ô∏è  Failed to archive $TAG"
            fi
          done
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Delete old assets from benchmarks-latest release
        run: |
          # Delete all existing JSON assets from benchmarks-latest release
          # This ensures only one JSON file exists per release
          RELEASE_ID=$(gh release view benchmarks-latest --repo ${{ github.repository }} --json id -q .id 2>/dev/null || echo "")
          
          if [ -n "$RELEASE_ID" ]; then
            echo "Found existing benchmarks-latest release, deleting old JSON assets..."
            ASSETS=$(gh release view benchmarks-latest --repo ${{ github.repository }} --json assets -q '.assets[] | select(.name | endswith(".json")) | .id' 2>/dev/null || echo "")
            
            for asset_id in $ASSETS; do
              echo "Deleting asset ID: $asset_id"
              gh api repos/${{ github.repository }}/releases/assets/$asset_id -X DELETE || echo "‚ö†Ô∏è  Failed to delete asset $asset_id"
            done
          else
            echo "No existing benchmarks-latest release found (will be created)"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Create or Update Release (benchmarks-latest)
        uses: softprops/action-gh-release@v1
        with:
          tag_name: benchmarks-latest
          name: Latest Benchmark Results
          body: |
            Latest benchmark results from self-hosted runner.
            
            **Run Number:** ${{ github.run_number }}
            **Commit:** ${{ github.sha }}
            **Generated:** ${{ github.event.head_commit.timestamp || github.run_id }}
            
            The GitHub Pages site automatically loads data from this release.
            
            This release is automatically updated on each benchmark run. Only one JSON file is kept per release.
          files: |
            ${{ steps.find_json.outputs.json_file }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Upload benchmark artifacts
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: |
            results/benchmark-results-consolidated-latest.json
          retention-days: 30

  # Deploy GitHub Pages after benchmarks complete
  deploy-pages:
    needs: run-benchmarks
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Pages
        uses: actions/configure-pages@v4
      
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'docs'
      
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

