<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Commons Benchmarks</title>
    <!-- Updated: Header with Bitcoin Commons branding -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
            padding: 0;
        }
        .header {
            background: linear-gradient(135deg, #f7931a 0%, #ffa64d 100%);
            color: white;
            padding: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 40px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }
        .logo-link {
            display: flex;
            align-items: center;
            text-decoration: none;
            color: white;
            transition: opacity 0.2s;
        }
        .logo-link:hover {
            opacity: 0.9;
        }
        .logo {
            height: 50px;
            width: auto;
            margin-right: 15px;
        }
        .logo-text {
            font-size: 2em;
            margin-right: 15px;
        }
        .header-title {
            flex: 1;
            min-width: 300px;
        }
        .header-title h1 {
            color: white;
            border: none;
            padding: 0;
            margin: 0 0 5px 0;
            font-size: 2em;
            font-weight: 700;
        }
        .subtitle {
            color: rgba(255,255,255,0.9);
            font-size: 0.95em;
            margin: 0;
        }
        .back-link {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            transition: background 0.2s;
            white-space: nowrap;
        }
        .back-link:hover {
            background: rgba(255,255,255,0.3);
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        h1 {
            color: #f7931a;
            border-bottom: 4px solid #f7931a;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                text-align: center;
            }
            .header-title h1 {
                font-size: 1.5em;
            }
            .back-link {
                width: 100%;
            }
        }
        h2 {
            color: #333;
            margin-top: 30px;
            margin-bottom: 15px;
            border-left: 4px solid #f7931a;
            padding-left: 15px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            background: #fee;
            border: 1px solid #fcc;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #c33;
        }
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #f7931a;
            color: white;
            font-weight: 600;
        }
        tr:hover {
            background: #f9f9f9;
        }
        .winner-core { color: #2196F3; font-weight: bold; }
        .winner-commons { color: #4CAF50; font-weight: bold; }
        .winner-tie { color: #666; }
        .speedup {
            color: #4CAF50;
            font-weight: bold;
        }
        .stats {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <a href="https://thebitcoincommons.org" class="logo-link" title="Bitcoin Commons">
                <img src="https://thebitcoincommons.org/logo.svg" alt="Bitcoin Commons Logo" class="logo" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
                <span class="logo-text" style="display: none;">‚ö°</span>
            </a>
            <div class="header-title">
                <h1>Bitcoin Commons Benchmarks</h1>
                <p class="subtitle">Performance comparison: Bitcoin Core vs Bitcoin Commons</p>
            </div>
            <a href="https://thebitcoincommons.org" class="back-link">‚Üê Back to Bitcoin Commons</a>
        </div>
    </div>
    <div class="container">
        <div id="loading" class="loading">Loading benchmark data...</div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="content" style="display: none;"></div>
    </div>

        <script>
            // Configuration
            // Priority: 1. Latest release (benchmarks-latest tag), 2. Local file (fallback), 3. Main branch
            const RELEASE_TAG = 'benchmarks-latest';
            const RELEASE_JSON_URL = `https://api.github.com/repos/BTCDecoded/bllvm-bench/releases/tags/${RELEASE_TAG}`;
            const LOCAL_JSON_URL = './data/benchmark-results-consolidated-latest.json';
            const MAIN_JSON_URL = 'https://raw.githubusercontent.com/BTCDecoded/bllvm-bench/main/docs/data/benchmark-results-consolidated-latest.json';
            
            // Load data on page load
            document.addEventListener('DOMContentLoaded', () => {
                loadBenchmarkData();
            });

        async function loadBenchmarkData() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const contentEl = document.getElementById('content');

            try {
                // Priority 1: Try to get from latest release (benchmarks-latest tag)
                let response;
                let jsonData;
                
                try {
                    console.log('Loading from release...');
                    const releaseResponse = await fetch(RELEASE_JSON_URL);
                    if (releaseResponse.ok) {
                        const release = await releaseResponse.json();
                        console.log('Release found:', release.tag_name);
                        // Find JSON asset in release
                        const jsonAsset = release.assets.find(a => a.name.includes('benchmark-results-consolidated') && a.name.endsWith('.json'));
                        if (jsonAsset) {
                            console.log('Found JSON asset:', jsonAsset.name);
                            // Use browser_download_url which works from browser
                            response = await fetch(jsonAsset.browser_download_url, {
                                method: 'GET',
                                headers: {
                                    'Accept': 'application/json',
                                },
                                // CORS should work for GitHub release assets
                            });
                            if (response.ok) {
                                jsonData = await response.json();
                                console.log('‚úÖ Loaded from release:', jsonAsset.name);
                            } else {
                                console.warn('Failed to fetch release asset:', response.status, response.statusText);
                            }
                        } else {
                            console.warn('No JSON asset found in release. Assets:', release.assets.map(a => a.name));
                        }
                    } else {
                        console.warn('Release API call failed:', releaseResponse.status, releaseResponse.statusText);
                    }
                } catch (releaseErr) {
                    console.log('Release not available:', releaseErr.message);
                    console.log('Trying local file...');
                }
                
                // Priority 2: Fallback to local file (for GitHub Pages)
                if (!jsonData) {
                    try {
                        response = await fetch(LOCAL_JSON_URL);
                        if (response.ok) {
                            jsonData = await response.json();
                            console.log('‚úÖ Loaded from local file');
                        }
                    } catch (e) {
                        console.log('Local file not found, trying main branch...');
                    }
                }
                
                // Priority 3: Fallback to main branch
                if (!jsonData) {
                    response = await fetch(MAIN_JSON_URL);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    jsonData = await response.json();
                    console.log('‚úÖ Loaded from main branch');
                }

                if (!jsonData || !jsonData.benchmarks) {
                    throw new Error('Invalid benchmark data format: missing "benchmarks" array');
                }

                renderBenchmarks(jsonData);
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
            } catch (error) {
                loadingEl.style.display = 'none';
                errorEl.textContent = `Failed to load benchmark data: ${error.message}`;
                errorEl.style.display = 'block';
                console.error('Error loading benchmarks:', error);
            }
        }

        function renderBenchmarks(data) {
            const contentEl = document.getElementById('content');
            let html = '';

            // Summary
            if (data.summary) {
                html += '<div class="info-box">';
                html += `<strong>Total Benchmarks:</strong> ${data.summary.total_benchmarks || 0}<br>`;
                html += `<strong>Core Wins:</strong> ${data.summary.core_wins || 0}<br>`;
                html += `<strong>Commons Wins:</strong> ${data.summary.commons_wins || 0}<br>`;
                if (data.timestamp) {
                    html += `<strong>Last Updated:</strong> ${new Date(data.timestamp).toLocaleString()}`;
                }
                html += '</div>';
            }

            // Benchmarks - data.benchmarks is an object with benchmark names as keys
            if (data.benchmarks && typeof data.benchmarks === 'object') {
                const benchmarks = Object.entries(data.benchmarks).map(([name, bench]) => ({
                    name,
                    ...bench
                }));
                
                const categories = groupByCategory(benchmarks);
                
                for (const [category, benchList] of Object.entries(categories)) {
                    html += `<h2>${category}</h2>`;
                    html += '<table>';
                    html += '<tr><th>Benchmark</th><th>Bitcoin Core</th><th>Bitcoin Commons</th><th>Winner</th><th>Speed Difference</th></tr>';
                    
                    for (const bench of benchList) {
                        const core = bench.core || {};
                        const commons = bench.commons || {};
                        const comparison = bench.comparison || {};
                        
                        // Extract time from various possible structures
                        const coreTime = extractTime(core);
                        const commonsTime = extractTime(commons);
                        const winner = comparison.winner || 'N/A';
                        const speedup = comparison.speedup || comparison.speed_difference || '';
                        
                        const winnerClass = winner === 'core' ? 'winner-core' : 
                                           winner === 'commons' ? 'winner-commons' : 'winner-tie';
                        
                        html += '<tr>';
                        html += `<td><strong>${bench.name || 'Unknown'}</strong></td>`;
                        html += `<td>${coreTime}</td>`;
                        html += `<td>${commonsTime}</td>`;
                        html += `<td class="${winnerClass}">${winner === 'core' ? 'üèÜ Core' : winner === 'commons' ? 'üèÜ Commons' : '‚Äî'}</td>`;
                        html += `<td class="speedup">${speedup}</td>`;
                        html += '</tr>';
                    }
                    
                    html += '</table>';
                }
            }

            contentEl.innerHTML = html;
        }

        function extractTime(data) {
            if (!data) return '‚Äî';
            
            // Try various time fields (direct)
            let time = data.time_ms || data.time_ns || data.time || 0;
            
            // If no direct time, look in nested structures
            if (!time || time === 0) {
                // Check benchmarks array
                if (data.benchmarks && Array.isArray(data.benchmarks) && data.benchmarks.length > 0) {
                    const firstBench = data.benchmarks[0];
                    time = firstBench.time_ms || firstBench.time_ns || firstBench.time || 0;
                }
                
                // Check nested objects (e.g., bitcoin_core_block_validation.primary_comparison.time_per_block_ms)
                if (!time || time === 0) {
                    const findNestedTime = (obj) => {
                        for (const key in obj) {
                            if (key.includes('time') && typeof obj[key] === 'number' && obj[key] > 0) {
                                return obj[key];
                            }
                            if (typeof obj[key] === 'object' && obj[key] !== null) {
                                const found = findNestedTime(obj[key]);
                                if (found) return found;
                            }
                        }
                        return 0;
                    };
                    time = findNestedTime(data);
                }
            }
            
            return formatTime(time);
        }

        function groupByCategory(benchmarks) {
            const categories = {};
            
            // Category mapping based on benchmark names
            const categoryMap = {
                'block': 'Block Operations',
                'transaction': 'Transaction Operations',
                'mempool': 'Mempool Operations',
                'script': 'Script Verification',
                'merkle': 'Merkle Tree',
                'hash': 'Hash Operations',
                'rpc': 'RPC Performance',
                'sync': 'Sync Performance',
                'memory': 'Memory Efficiency',
                'concurrent': 'Concurrent Operations'
            };
            
            for (const bench of benchmarks) {
                // Determine category from benchmark name
                let category = 'General';
                const nameLower = (bench.name || '').toLowerCase();
                
                for (const [key, cat] of Object.entries(categoryMap)) {
                    if (nameLower.includes(key)) {
                        category = cat;
                        break;
                    }
                }
                
                if (!categories[category]) {
                    categories[category] = [];
                }
                categories[category].push(bench);
            }
            
            return categories;
        }

        function formatTime(time) {
            if (!time || time === 0 || isNaN(time)) return '‚Äî';
            
            // If time is in nanoseconds, convert to appropriate unit
            if (time < 1) {
                return `${(time * 1000).toFixed(2)} ns`;
            } else if (time < 1000) {
                return `${time.toFixed(2)} ns`;
            } else if (time < 1000000) {
                return `${(time / 1000).toFixed(2)} ¬µs`;
            } else if (time < 1000000000) {
                return `${(time / 1000000).toFixed(2)} ms`;
            } else {
                return `${(time / 1000000000).toFixed(2)} s`;
            }
        }

        // Auto-load on page load (handle both loading and loaded states)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadBenchmarkData);
        } else {
            // Already loaded, call immediately
            loadBenchmarkData();
        }
        </script>
    </body>
</html>

